<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Copilot Anywhere</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
body { font-family: system-ui, sans-serif; margin: 0; padding: 1rem; background:#0f1115; color:#edf2f7; }
header { font-size: 1.25rem; margin-bottom: 1rem; }
#inputRow { display:flex; gap:.5rem; margin-bottom:1rem; }
#prompt { flex:1; padding:.5rem .75rem; font-size:1rem; border-radius:6px; border:1px solid #2d3748; background:#1a202c; color:#f7fafc; }
select.modeSel { padding:.5rem .5rem; font-size:.85rem; background:#1a202c; color:#e2e8f0; border:1px solid #2d3748; border-radius:6px; font-weight:600; letter-spacing:.5px; }
button { padding:.6rem 1rem; background:#3182ce; border:none; color:#fff; border-radius:6px; cursor:pointer; font-weight:600; }
button:disabled { opacity:.5; cursor: not-allowed; }
#log { white-space: pre-wrap; background:#1a202c; padding:1rem; border-radius:8px; min-height:260px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; overflow:auto; }
.tag { display:inline-block; background:#2d3748; padding:2px 6px; margin-right:6px; border-radius:4px; font-size:.75rem; color:#a0aec0; }
.fragment { color:#63b3ed; }
.inbound { color:#cbd5e0; }
.done { color:#9ae6b4; }
.model { color:#f6ad55; }
/* Modal */
#optionsOverlay { position:fixed; inset:0; background:rgba(15,17,21,.75); display:none; align-items:center; justify-content:center; z-index:1000; }
#optionsModal { background:#1a202c; padding:1rem 1.25rem 1.25rem; border-radius:10px; width:340px; max-width:90%; box-shadow:0 8px 32px rgba(0,0,0,.45); }
#optionsModal h2 { margin:0 0 .9rem; font-size:1rem; letter-spacing:.05em; }
.optionRow { display:flex; align-items:center; justify-content:space-between; margin-bottom:.9rem; gap:.75rem; }
.optionRow label { flex:1; font-size:.8rem; color:#cbd5e0; line-height:1.2; }
.optionRow input[type=checkbox] { transform:scale(1.15); cursor:pointer; }
#closeOptions { background:#4a5568; font-size:.7rem; padding:.45rem .7rem; }
#optionsBtn { background:#4a5568; font-size:.7rem; padding:.45rem .7rem; }
.divider { height:1px; background:#2d3748; margin:.75rem -1.25rem; }
.subtle { font-size:.65rem; color:#718096; margin-top:-.5rem; margin-bottom:.75rem; }
/* Markdown / code styling */
.md-answer { line-height:1.45; }
.md-answer p { margin:.4rem 0; }
.md-answer h1,.md-answer h2,.md-answer h3 { font-weight:600; line-height:1.2; margin:.9rem 0 .4rem; }
.md-answer h1 { font-size:1.15rem; }
.md-answer h2 { font-size:1.05rem; }
.md-answer h3 { font-size:.95rem; }
.md-answer code { background:#2d3748; padding:2px 5px; border-radius:4px; font-size:.8rem; font-family:ui-monospace, SFMono-Regular, Menlo, monospace; }
.md-answer pre { background:#1a2433; padding:.75rem .9rem; border-radius:8px; overflow:auto; font-size:.75rem; line-height:1.35; border:1px solid #2d3b4d; }
.md-answer pre code { background:transparent; padding:0; }
.md-answer ul { margin:.4rem 0 .6rem .9rem; padding:0; }
.md-answer li { margin:.25rem 0; }
.token-key { color:#63b3ed; }
.token-string { color:#9ae6b4; }
.token-number { color:#f6ad55; }
.token-boolean { color:#ed64a6; }
.token-null { color:#a0aec0; font-style:italic; }
</style>
</head>
<body>
<header style="display:flex; justify-content:space-between; align-items:center; gap:1rem; flex-wrap:wrap;">
  <span>Copilot Anywhere Web Client</span>
<div style="display:flex; gap:.5rem;">
    <button id="optionsBtn">Options</button>
</div>
</header>
<div id="optionsOverlay">
    <div id="optionsModal" role="dialog" aria-modal="true" aria-labelledby="optsTitle">
        <h2 id="optsTitle">Options</h2>
        <div class="optionRow">
            <label for="debugToggle">Debug view (show fragments, info, inbound, done lines)</label>
            <input type="checkbox" id="debugToggle" />
        </div>
        <div class="optionRow" style="margin-top:-.5rem;">
            <label for="notifyToggle">Desktop notifications on completion</label>
            <input type="checkbox" id="notifyToggle" />
        </div>
        <p class="subtle" id="notifyStatus"></p>
        <div class="divider"></div>
        <div style="display:flex; justify-content:flex-end; gap:.5rem;">
            <button id="closeOptions">Close</button>
        </div>
    </div>
</div>
<div style="display:flex; gap:1rem; flex-wrap:wrap; align-items:flex-start;">
  <div style="min-width:220px; flex:0 0 220px;">
    <h3 style="margin:0 0 .5rem; font-size:.9rem; letter-spacing:.05em; color:#a0aec0;">Projects</h3>
    <div id="sessions" style="background:#1a202c; padding:.5rem; border-radius:6px; max-height:300px; overflow:auto;"></div>
  </div>
  <div style="flex:1; min-width:320px;">
    <div id="inputRow">
      <select id="mode" class="modeSel" title="Mode">
        <option value="ask">Ask</option>
        <option value="agent">Agent</option>
      </select>
      <input id="prompt" placeholder="Ask anything (Enter to send)" />
      <button id="sendBtn">Send</button>
    </div>
    <div id="activeSessionLabel" style="font-size:.75rem; color:#a0aec0; margin-bottom:.4rem;">No session selected</div>
    <div id="log" aria-live="polite"></div>
  </div>
</div>
<script>
const host = location.origin; // assumes served from root
let sessionNameMap = {}; // id -> name
let currentSession = null; // session id
let sessionEventSource = null;
const logEl = document.getElementById('log');
const promptEl = document.getElementById('prompt');
const modeEl = document.getElementById('mode');
const sendBtn = document.getElementById('sendBtn');
    // Preferences
    let debugEnabled = (localStorage.getItem('ca_debug') ?? '1') !== '0';
    let notifyPref = (localStorage.getItem('ca_notify') === '1');

    // Types always visible (not hidden in non-debug mode)
    const primaryTypes = new Set(['outgoing', 'answer', 'error', 'inbound']);

    function applyDebugVisibility() {
        const hidden = !debugEnabled;
        document.querySelectorAll('.debug-line').forEach(el => {
            el.style.display = hidden ? 'none' : '';
        });
    }

function append(type, text, extra={}) {
  const line = document.createElement('div');
  line.className = type;
    const isDebug = !primaryTypes.has(type); // everything not in primaryTypes treated as debug
    if (isDebug) line.classList.add('debug-line');
  const badge = document.createElement('span');
  badge.className = 'tag';
  badge.textContent = type.toUpperCase();
  line.appendChild(badge);
  if (extra.agentTag) {
    const ag = document.createElement('span');
    ag.className = 'tag';
    ag.style.background = '#553c9a';
    ag.style.color = '#d6bcfa';
    ag.textContent = 'AGENT';
    line.appendChild(ag);
  }
    if (extra.model && !(extra.model === 'agent' && extra.agentTag)) {
    const m = document.createElement('span');
    m.className='tag model';
    m.textContent = extra.model;
    line.appendChild(m);
  }
  const span = document.createElement('span');
  if (type === 'answer') {
    span.className = 'md-answer';
    span.innerHTML = renderMarkdown(safeTruncate(text, 20000));
  } else {
    span.textContent = text;
  }
  line.appendChild(span);
    if (!debugEnabled && isDebug) {
        line.style.display = 'none';
    }
  logEl.appendChild(line);
  logEl.scrollTop = logEl.scrollHeight;
}

// --- Markdown Rendering (minimal) ---
function escapeHtml(s){return s.replace(/[&<>"']/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));}
function safeTruncate(s, max){ return s.length>max ? s.slice(0,max)+"\n...truncated..." : s; }
function highlightJson(code){
  try { const obj = JSON.parse(code); return syntaxColorJson(obj); } catch { /* fallback */ }
  return escapeHtml(code);
}
function syntaxColorJson(obj){
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/(&|<|>|"|')/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]))
            .replace(/("(\\u[0-9a-fA-F]{4}|\\[^u]|[^\\"])*"\s*:)/g,'<span class="token-key">$1</span>')
            .replace(/"(\\u[0-9a-fA-F]{4}|\\[^u]|[^\\"])*"/g,'<span class="token-string">$&</span>')
            .replace(/\b(true|false)\b/g,'<span class="token-boolean">$1</span>')
            .replace(/\b(null)\b/g,'<span class="token-null">$1</span>')
            .replace(/(-?\b\d+(?:\.\d+)?(?:e[+\-]?\d+)?\b)/gi,'<span class="token-number">$1</span>');
}
function renderMarkdown(src){
  // Extract fenced code blocks first
  const fences = [];
  let i=0; let text = src.replace(/```([a-zA-Z0-9_-]*)\n([\s\S]*?)```/g,(m,lang,code)=>{const token='__CODE_FENCE_'+(i++)+'__'; fences.push({token, lang: (lang||'').toLowerCase(), code}); return token;});
  // Basic escapes
  text = escapeHtml(text);
  // Headings
  text = text.replace(/^###### (.*)$/gm,'<h6>$1</h6>')
             .replace(/^##### (.*)$/gm,'<h5>$1</h5>')
             .replace(/^#### (.*)$/gm,'<h4>$1</h4>')
             .replace(/^### (.*)$/gm,'<h3>$1</h3>')
             .replace(/^## (.*)$/gm,'<h2>$1</h2>')
             .replace(/^# (.*)$/gm,'<h1>$1</h1>');
  // Bold / italic
  text = text.replace(/\*\*([^*]+)\*\*/g,'<strong>$1</strong>')
             .replace(/\*([^*]+)\*/g,'<em>$1</em>');
  // Inline code
  text = text.replace(/`([^`]+)`/g,(m,code)=>'<code>'+escapeHtml(code)+'</code>');
  // Lists
  text = text.replace(/^(?:- |\* )(.*)$/gm,'<li>$1</li>');
  text = text.replace(/(<li>[^<]+<\/li>\n?)+/g,m=>'<ul>'+m.replace(/\n/g,'')+'</ul>');
  // Paragraphs (split by blank lines)
  text = text.replace(/(?:^|\n)([^<\n][^\n]*)(?=\n|$)/g,(m,line)=>{ if(/^<h\d|<ul>|<li>|<pre>|<blockquote>|<p>|<\/ul>|<\/li>/.test(line.trim())) return m; return '\n<p>'+line.trim()+'</p>'; });
  // Restore fences
  for(const f of fences){
    let rendered;
    if(['json','application/json'].includes(f.lang)) {
      rendered = '<pre><code>'+highlightJson(f.code)+'</code></pre>';
    } else {
      const escaped = escapeHtml(f.code);
      rendered = '<pre><code>'+escaped+'</code></pre>';
    }
    text = text.replace(f.token, rendered);
  }
  return text;
}

async function sendPrompt() {
  const value = promptEl.value.trim();
  if (!value) return;
  const mode = modeEl.value;
  const outgoingText = mode === 'agent' && !value.toLowerCase().startsWith('agent:') ? 'agent: '+value : value;
  sendBtn.disabled = true;
  append('outgoing', outgoingText, { agentTag: mode === 'agent' });
  try {
    const payload = { text: outgoingText, mode: mode === 'agent' ? 'agent' : undefined };
    if (currentSession) payload.sessionId = currentSession;
    const res = await fetch(host + '/message', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
    if (!res.ok) {
      const t = await res.text();
      append('error', 'HTTP error: '+t);
    } else {
      const data = await res.json();
      append('info', 'Sent id='+data.id, { agentTag: mode === 'agent' });
    }
  } catch (e) {
    append('error', 'Network error '+e);
  } finally {
    sendBtn.disabled = false;
    promptEl.value='';
    promptEl.focus();
  }
}

sendBtn.addEventListener('click', sendPrompt);
promptEl.addEventListener('keydown', e => { if (e.key==='Enter') sendPrompt(); });

function connectSessionStream() {
  if (sessionEventSource) { sessionEventSource.close(); }
  const url = currentSession ? `${host}/events?session=${encodeURIComponent(currentSession)}` : `${host}/events`;
  sessionEventSource = new EventSource(url);
  const buffer = {};
  sessionEventSource.addEventListener('inbound', ev => {
    const data = JSON.parse(ev.data);
    append('inbound', data.text, { id: data.id });
  });
  sessionEventSource.addEventListener('fragment', ev => {
    const data = JSON.parse(ev.data);
    if (!buffer[data.id]) buffer[data.id] = '';
    buffer[data.id] += data.fragment;
  const isAgent = data.model === 'agent' || /\(agent step/.test(data.fragment);
  append('fragment', data.fragment, { id: data.id, model: data.model, agentTag: isAgent });
  });
  sessionEventSource.addEventListener('done', ev => {
    const data = JSON.parse(ev.data);
  const isAgent = data.model === 'agent';
  append('done', 'Complete for id='+data.id+' (model '+data.model+')', { agentTag: isAgent });
    if (buffer[data.id]) {
      const answerText = buffer[data.id];
        const isAgent = /\[actions\]/.test(answerText) || /Agent finished|Agent reached max steps/i.test(answerText);
        const clean = isAgent ? sanitizeAgentAnswer(answerText) : answerText;
        append('answer', clean, { agentTag: isAgent });
      notifyCompletion(data, answerText);
    } else {
      notifyCompletion(data, '');
    }
  });
}

        // Remove noisy agent trace decorations for cleaner final display
        function sanitizeAgentAnswer(text) {
            let cleaned = text.replace(/\(agent step \d+\/\d+\)/g, '');
            // Collapse multiple spaces/newlines created by stripping
            cleaned = cleaned.replace(/\n{3,}/g, '\n\n').replace(/ {2,}/g, ' ');
            return cleaned.trim();
        }

async function refreshSessions() {
  try {
    const res = await fetch(host + '/sessions');
    if (!res.ok) return;
    const list = await res.json();
    const container = document.getElementById('sessions');
    container.innerHTML = '';
    sessionNameMap = {};
    list.forEach(s => {
      sessionNameMap[s.id] = s.name;
      const btn = document.createElement('button');
      btn.textContent = s.name;
      btn.style.display='block';
      btn.style.width='100%';
      btn.style.margin='0 0 4px';
      btn.style.background = (s.id===currentSession)?'#2b6cb0':'#2d3748';
      btn.style.fontSize='.8rem';
        btn.addEventListener('click', () => { selectSession(s.id, s.name); });
      container.appendChild(btn);
    });
    // Auto-select first session if none selected
    if (!currentSession && list.length) {
                                    selectSession(list[0].id, list[0].name);
                                }
                            } catch { }
                        }

                        async function selectSession(id, name) {
                            currentSession = id;
                            document.getElementById('log').innerHTML = '';
                            document.getElementById('activeSessionLabel').textContent = 'Session: ' + name;
                            await replayHistory(id);
                            connectSessionStream();
                        }

    async function replayHistory(id) {
        try {
            const res = await fetch(host + '/sessions/' + encodeURIComponent(id));
            if (!res.ok) return;
            const data = await res.json();
            const msgs = data.messages || [];
            if (!msgs.length) {
                append('info', 'No prior history for this session yet.');
            }
            msgs.forEach(m => {
                if (m.direction === 'inbound') {
                    append('inbound', m.text || '', { id: m.id });
                } else if (m.direction === 'outbound') {
                    if (m.fragment) {
                        const isAgent = m.model === 'agent' || /(agent step)/.test(m.fragment);
                        append('fragment', m.fragment, { id: m.id, model: m.model, agentTag: isAgent });
                        if (m.done) {
                            append('done', 'Complete for id=' + m.id + ' (model ' + m.model + ')', { agentTag: isAgent });
                        }
                    }
                }
            });
  } catch {}
}

// Notification Handling
function requestNotifyPermission() {
  if (!('Notification' in window)) { append('info','Notifications not supported'); return; }
  if (Notification.permission === 'default') {
    Notification.requestPermission().then(p => {
      append('info', 'Notification permission: '+p);
    });
  } else {
    append('info', 'Notification permission already: '+Notification.permission);
  }
}

function notifyCompletion(doneData, answer) {
  if (!('Notification' in window)) return;
  if (Notification.permission !== 'granted') return; // silent if not granted
  try {
    const sessName = sessionNameMap[doneData.sessionId] || 'session';
    const snippet = (answer||'').replace(/\s+/g,' ').slice(0,140) + (answer && answer.length>140 ? '…' : '');
    new Notification(`Response complete (${sessName})`, { body: snippet || `id ${doneData.id} finished`, tag: doneData.id });
  } catch {}
}

    // Options modal wiring
    const optionsOverlay = document.getElementById('optionsOverlay');
    const optionsBtn = document.getElementById('optionsBtn');
    const closeOptions = document.getElementById('closeOptions');
    const debugToggle = document.getElementById('debugToggle');
    const notifyToggle = document.getElementById('notifyToggle');
    const notifyStatus = document.getElementById('notifyStatus');

    function openOptions() { optionsOverlay.style.display = 'flex'; debugToggle.focus(); updateNotifyStatus(); }
    function closeOptionsModal() { optionsOverlay.style.display = 'none'; }

    optionsBtn.addEventListener('click', openOptions);
    closeOptions.addEventListener('click', closeOptionsModal);
    optionsOverlay.addEventListener('click', e => { if (e.target === optionsOverlay) closeOptionsModal(); });
    document.addEventListener('keydown', e => { if (e.key === 'Escape' && optionsOverlay.style.display === 'flex') closeOptionsModal(); });

    debugToggle.checked = debugEnabled;
    debugToggle.addEventListener('change', () => { debugEnabled = debugToggle.checked; localStorage.setItem('ca_debug', debugEnabled ? '1' : '0'); applyDebugVisibility(); });

    notifyToggle.checked = notifyPref;
    notifyToggle.addEventListener('change', () => { notifyPref = notifyToggle.checked; localStorage.setItem('ca_notify', notifyPref ? '1' : '0'); if (notifyPref) requestNotifyPermission(); updateNotifyStatus(); });

    function updateNotifyStatus() {
        if (!('Notification' in window)) { notifyStatus.textContent = 'Notifications not supported in this browser.'; return; }
        notifyStatus.textContent = 'Permission: ' + Notification.permission + (notifyPref ? ' (enabled)' : ' (disabled)');
    }

    applyDebugVisibility();
    updateNotifyStatus();

    // Load full context first, then sessions UI (ensures race-free initial history rendering)
    (async function init() {
        try {
            const res = await fetch(host + '/context');
            if (res.ok) {
                const data = await res.json();
                // Pre-populate session list if not already loaded (still call refreshSessions to build buttons)
                // We rely on refreshSessions for UI; context ensures /sessions/<id> won't 404.
            }
        } catch { }
        await refreshSessions();
    })();
</script>
</body>
</html>